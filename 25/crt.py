def get_euclid_coefficients(a, b):
    """
    Given positive integers (a, b), find the coefficients in the equations
    generated by Euclid's algorithm to find hcf(a, b). These can be used to
    generate Bezout's identity.
    """
    assert a >= b
    x = a // b
    r = a % b
    if r == 0:
        return []
    return get_euclid_coefficients(b, r) + [x]


def get_bezout_coefficients(a, b):
    """
    Given (a, b), find (x, y) such that:
        a * x + b * y == hcf(a, b)
    """
    if a < b:
        y, x = get_bezout_coefficients(b, a)
        return x, y

    cs = get_euclid_coefficients(a, b)
    x, y = 0, 1
    for c in cs:
        x, y = y, x - (y * c)

    return x, y


def get_product(numbers):
    product = 1
    for number in numbers:
        product *= number
    return product


def chinese_remainder_theorem(congruences):
    """
    Given a list of entries of the form (a, n), each corresponding to a
    congruence x % n == a, where all the `n` are relatively coprime, find the
    smallest positive integer x satisfying all these congruences.
    """
    product = get_product(n for _, n in congruences)
    moduli_products = [product // n for _, n in congruences]
    bezout_coefficients = [
        get_bezout_coefficients(moduli_product, n)
        for (_, n), moduli_product in zip(congruences, moduli_products)
    ]
    solution = 0
    for (a, n), (x, y), moduli_product in zip(
        congruences, bezout_coefficients, moduli_products
    ):
        assert moduli_product * x + n * y == 1
        if a < 0:
            a += n
        solution += a * x * moduli_product

    return (solution % product)
